<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.0.2, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 4.2.0.

Copyright 1991, 1993-2023 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with no Front-Cover Texts, and with no Back-Cover Texts.  A copy of the
license is included in GNU Free Documentation License. -->
<title>Arithmetic Functions (GNU MPFR 4.2.0)</title>

<meta name="description" content="How to install and use GNU MPFR, a library for reliable multiple precision
floating-point arithmetic, version 4.2.0.">
<meta name="keywords" content="Arithmetic Functions (GNU MPFR 4.2.0)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="MPFR-Interface.html" rel="up" title="MPFR Interface">
<link href="Comparison-Functions.html" rel="next" title="Comparison Functions">
<link href="Conversion-Functions.html" rel="prev" title="Conversion Functions">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Arithmetic-Functions">
<div class="nav-panel">
<p>
Next: <a href="Comparison-Functions.html" accesskey="n" rel="next">Comparison Functions</a>, Previous: <a href="Conversion-Functions.html" accesskey="p" rel="prev">Conversion Functions</a>, Up: <a href="MPFR-Interface.html" accesskey="u" rel="up">MPFR Interface</a>   [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a class="index-entry-id" id="index-Arithmetic-functions"></a>
<h3 class="section" id="Arithmetic-Functions-1">5.5 Arithmetic Functions</h3>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fadd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fadd_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd_005fui'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fadd_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd_005fsi'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fadd_005fd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, double <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd_005fd'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fadd_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpz_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd_005fz'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fadd_005fq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_add_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpq_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fadd_005fq'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var> + <var class="var">op2</var><!-- /@w --> rounded in the direction
<var class="var">rnd</var>.  The IEEE 754 rules are used, in particular for signed zeros.
But for types having no signed zeros, 0 is considered unsigned
(i.e., (+0) + 0 = (+0)<!-- /@w --> and (−0) + 0 = (−0)<!-- /@w -->).
The <code class="code">mpfr_add_d</code> function assumes that the radix of the <code class="code">double</code> type
is a power of 2, with a precision at most that declared by the C implementation
(macro <code class="code">IEEE_DBL_MANT_DIG</code>, and if not defined 53 bits).
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsub"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fui_005fsub"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_ui_sub</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fui_005fsub'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsub_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub_005fui'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsi_005fsub"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_si_sub</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long int <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsi_005fsub'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsub_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub_005fsi'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fd_005fsub"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_d_sub</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, double <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fd_005fsub'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsub_005fd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, double <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub_005fd'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fz_005fsub"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_z_sub</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpz_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fz_005fsub'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsub_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpz_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub_005fz'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsub_005fq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sub_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpq_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsub_005fq'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var> − <var class="var">op2</var><!-- /@w --> rounded in the direction
<var class="var">rnd</var>.  The IEEE 754 rules are used, in particular for signed zeros.
But for types having no signed zeros, 0 is considered unsigned
(i.e., (+0) − 0 = (+0)<!-- /@w -->, (−0) − 0 = (−0)<!-- /@w -->,
0 − (+0) = (−0)<!-- /@w --> and 0 − (−0) = (+0)<!-- /@w -->).
The same restrictions as for <code class="code">mpfr_add_d</code> apply to <code class="code">mpfr_d_sub</code>
and <code class="code">mpfr_sub_d</code>.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fmul"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005fui'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005fsi'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005fd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, double <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005fd'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpz_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005fz'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005fq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpq_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005fq'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var> times <var class="var">op2</var><!-- /@w --> rounded in the
direction <var class="var">rnd</var>.
When a result is zero, its sign is the product of the signs of the operands
(for types having no signed zeros, 0 is considered positive).
The same restrictions as for <code class="code">mpfr_add_d</code> apply to <code class="code">mpfr_mul_d</code>.
Note: when <var class="var">op1</var> and <var class="var">op2</var> are equal, use <code class="code">mpfr_sqr</code> instead of
<code class="code">mpfr_mul</code> for better efficiency.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsqr"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sqr</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsqr'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the square of <var class="var">op</var>
rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fdiv"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fui_005fdiv"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_ui_div</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fui_005fdiv'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005fui'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsi_005fdiv"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_si_div</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long int <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsi_005fdiv'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005fsi'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fd_005fdiv"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_d_div</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, double <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fd_005fdiv'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005fd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, double <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005fd'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpz_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005fz'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005fq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpq_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005fq'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var> / <var class="var">op2</var><!-- /@w --> rounded in the direction <var class="var">rnd</var>.
When a result is zero, its sign is the product of the signs of the operands.
For types having no signed zeros, 0 is considered positive; but note that if
<var class="var">op1</var> is non-zero and <var class="var">op2</var> is zero, the result might change from
±Inf to NaN in future MPFR versions if there is an opposite decision
on the IEEE 754 side.
The same restrictions as for <code class="code">mpfr_add_d</code> apply to <code class="code">mpfr_d_div</code>
and <code class="code">mpfr_div_d</code>.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsqrt"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sqrt</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsqrt'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fsqrt_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sqrt_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsqrt_005fui'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the square root of <var class="var">op</var>
rounded in the direction <var class="var">rnd</var>.  Set <var class="var">rop</var> to −0 if
<var class="var">op</var> is −0, to be consistent with the IEEE 754 standard
(thus this differs from <code class="code">mpfr_rootn_ui</code> and <code class="code">mpfr_rootn_si</code>
with <var class="var">n</var> = 2<!-- /@w -->).
Set <var class="var">rop</var> to NaN if <var class="var">op</var> is negative.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005frec_005fsqrt"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rec_sqrt</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frec_005fsqrt'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the reciprocal square root of <var class="var">op</var>
rounded in the direction <var class="var">rnd</var>.  Set <var class="var">rop</var> to +Inf if <var class="var">op</var> is
±0, +0 if <var class="var">op</var> is +Inf, and NaN if <var class="var">op</var> is negative.
Warning!  Therefore the result on −0 is different from the one of the
rSqrt function recommended by the IEEE 754 standard (Section 9.2.1),
which is −Inf instead of +Inf. However, <code class="code">mpfr_rec_sqrt</code> is
equivalent to <code class="code">mpfr_rootn_si</code> with <var class="var">n</var> = −2<!-- /@w -->.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fcbrt"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_cbrt</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fcbrt'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005frootn_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rootn_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, unsigned long int <var class="var">n</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frootn_005fui'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005frootn_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_rootn_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, long int <var class="var">n</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005frootn_005fsi'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the <var class="var">n</var>th root (with <var class="var">n</var> = 3<!-- /@w -->, the cubic root,
for <code class="code">mpfr_cbrt</code>) of <var class="var">op</var> rounded in the direction <var class="var">rnd</var>.
For <var class="var">n</var> = 0<!-- /@w -->, set <var class="var">rop</var> to NaN.
For <var class="var">n</var> odd (resp. even) and <var class="var">op</var> negative (including −Inf),
set <var class="var">rop</var> to a negative number (resp. NaN).
If <var class="var">op</var> is zero, set <var class="var">rop</var> to zero with the sign obtained by the
usual limit rules, i.e., the same sign as <var class="var">op</var> if <var class="var">n</var> is odd, and
positive if <var class="var">n</var> is even.
</p>
<p>These functions agree with the rootn operation of the IEEE 754 standard.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005froot"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_root</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, unsigned long int <var class="var">n</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005froot'> ¶</a></span></dt>
<dd><p>This function is the same as <code class="code">mpfr_rootn_ui</code> except when <var class="var">op</var>
is −0 and <var class="var">n</var> is even: the result is −0 instead of +0
(the reason was to be consistent with <code class="code">mpfr_sqrt</code>). Said otherwise,
if <var class="var">op</var> is zero, set <var class="var">rop</var> to <var class="var">op</var>.
</p>
<p>This function predates IEEE 754-2008, where rootn was introduced, and
behaves differently from the IEEE 754 rootn operation. It is marked as
deprecated and will be removed in a future release.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fneg"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_neg</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fneg'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fabs"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_abs</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fabs'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to −<var class="var">op</var><!-- /@w --> and the absolute value of <var class="var">op</var>
respectively, rounded in the direction <var class="var">rnd</var>.
Just changes or adjusts
the sign if <var class="var">rop</var> and <var class="var">op</var> are the same variable,
otherwise a rounding might occur if the precision of <var class="var">rop</var> is less than
that of <var class="var">op</var>.
</p>
<p>The sign rule also applies to NaN in order to mimic the IEEE 754
<code class="code">negate</code> and <code class="code">abs</code> operations, i.e., for <code class="code">mpfr_neg</code>, the
sign is reversed, and for <code class="code">mpfr_abs</code>, the sign is set to positive.
But contrary to IEEE 754, the NaN flag is set as usual.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fdim"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_dim</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdim'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the positive difference of <var class="var">op1</var> and <var class="var">op2</var>, i.e.,
<var class="var">op1</var> − <var class="var">op2</var><!-- /@w --> rounded in the direction <var class="var">rnd</var>
if <var class="var">op1</var> &gt; <var class="var">op2</var><!-- /@w -->, +0 if <var class="var">op1</var> &lt;= <var class="var">op2</var><!-- /@w -->,
and NaN if <var class="var">op1</var> or <var class="var">op2</var> is NaN.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fmul_005f2ui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_2ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005f2ui'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fmul_005f2si"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_mul_2si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fmul_005f2si'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var> times 2 raised
to <var class="var">op2</var>
rounded in the direction <var class="var">rnd</var>. Just increases the exponent by <var class="var">op2</var>
when <var class="var">rop</var> and <var class="var">op1</var> are identical.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fdiv_005f2ui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_2ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, unsigned long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005f2ui'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fdiv_005f2si"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_div_2si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, long int <var class="var">op2</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdiv_005f2si'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to <var class="var">op1</var> divided by 2 raised
to <var class="var">op2</var>
rounded in the direction <var class="var">rnd</var>. Just decreases the exponent by <var class="var">op2</var>
when <var class="var">rop</var> and <var class="var">op1</var> are identical.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffac_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fac_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffac_005fui'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the factorial of <var class="var">op</var>, rounded in the direction <var class="var">rnd</var>.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffma"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fma</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_t <var class="var">op3</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffma'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffms"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fms</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_t <var class="var">op3</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffms'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to (<var class="var">op1</var> times <var class="var">op2</var>) + <var class="var">op3</var><!-- /@w -->
(resp. (<var class="var">op1</var> times <var class="var">op2</var>) − <var class="var">op3</var><!-- /@w -->)
rounded in the direction <var class="var">rnd</var>.  Concerning special values (signed zeros,
infinities, NaN), these functions behave like a multiplication followed by a
separate addition or subtraction.  That is, the fused operation matters only
for rounding.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005ffmma"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fmma</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_t <var class="var">op3</var>, mpfr_t <var class="var">op4</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffmma'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005ffmms"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_fmms</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op1</var>, mpfr_t <var class="var">op2</var>, mpfr_t <var class="var">op3</var>, mpfr_t <var class="var">op4</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005ffmms'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to
(<var class="var">op1</var> times <var class="var">op2</var>) + (<var class="var">op3</var> times <var class="var">op4</var>)<!-- /@w -->
(resp.
(<var class="var">op1</var> times <var class="var">op2</var>) − (<var class="var">op3</var> times <var class="var">op4</var>)<!-- /@w -->)
rounded in the direction <var class="var">rnd</var>.
In case the computation of <var class="var">op1</var> times <var class="var">op2</var><!-- /@w --> overflows or
underflows (or that of <var class="var">op3</var> times <var class="var">op4</var><!-- /@w -->), the result
<var class="var">rop</var> is computed as if the two intermediate products were computed with
rounding toward zero.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fhypot"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_hypot</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">x</var>, mpfr_t <var class="var">y</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fhypot'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the Euclidean norm of <var class="var">x</var> and <var class="var">y</var>, i.e.,
the square root of the sum of the squares
of <var class="var">x</var> and <var class="var">y</var>, rounded in the direction <var class="var">rnd</var>.
Special values are handled as described in the ISO C99 (Section F.9.4.3)
and IEEE 754 (Section 9.2.1) standards:
If <var class="var">x</var> or <var class="var">y</var> is an infinity, then +Inf is returned in <var class="var">rop</var>,
even if the other number is NaN.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fsum"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_sum</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, const mpfr_ptr <var class="var">tab</var>[], unsigned long int <var class="var">n</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fsum'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the sum of all elements of <var class="var">tab</var>, whose size is <var class="var">n</var>,
correctly rounded in the direction <var class="var">rnd</var>. Warning: for efficiency reasons,
<var class="var">tab</var> is an array of pointers
to <code class="code">mpfr_t</code>, not an array of <code class="code">mpfr_t</code>.
If <var class="var">n</var> = 0<!-- /@w -->, then the result is +0, and if <var class="var">n</var> = 1<!-- /@w -->,
then the function is equivalent to <code class="code">mpfr_set</code>.
For the special exact cases, the result is the same as the one obtained
with a succession of additions (<code class="code">mpfr_add</code>) in infinite precision.
In particular, if the result is an exact zero and <var class="var">n</var> &gt;= 1<!-- /@w -->:
</p><ul class="itemize mark-bullet">
<li>if all the inputs have the same sign (i.e., all +0 or
all −0), then the result has the same sign as the inputs;
</li><li>otherwise, either because all inputs are zeros with at least
a +0 and a −0, or because some inputs are non-zero
(but they globally cancel), the result is +0, except for the
<code class="code">MPFR_RNDD</code> rounding mode, where it is −0.
</li></ul>
</dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fdot"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_dot</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, const mpfr_ptr <var class="var">a</var>[], const mpfr_ptr <var class="var">b</var>[], unsigned long int <var class="var">n</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fdot'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the dot product of elements of <var class="var">a</var> by those of <var class="var">b</var>,
whose common size is <var class="var">n</var>,
correctly rounded in the direction <var class="var">rnd</var>. Warning: for efficiency reasons,
<var class="var">a</var> and <var class="var">b</var> are arrays of pointers to <code class="code">mpfr_t</code>.
This function is experimental, and does not yet handle intermediate overflows
and underflows.
</p></dd></dl>

<p>For the power functions (with an integer exponent or not), see <a class="ref" href="Transcendental-Functions.html#mpfr_005fpow">mpfr_pow</a>
in <a class="ref" href="Transcendental-Functions.html">Transcendental Functions</a>.
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Comparison-Functions.html">Comparison Functions</a>, Previous: <a href="Conversion-Functions.html">Conversion Functions</a>, Up: <a href="MPFR-Interface.html">MPFR Interface</a>   [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
