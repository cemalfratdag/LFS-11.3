<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.0.2, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 4.2.0.

Copyright 1991, 1993-2023 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with no Front-Cover Texts, and with no Back-Cover Texts.  A copy of the
license is included in GNU Free Documentation License. -->
<title>Assignment Functions (GNU MPFR 4.2.0)</title>

<meta name="description" content="How to install and use GNU MPFR, a library for reliable multiple precision
floating-point arithmetic, version 4.2.0.">
<meta name="keywords" content="Assignment Functions (GNU MPFR 4.2.0)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="MPFR-Interface.html" rel="up" title="MPFR Interface">
<link href="Combined-Initialization-and-Assignment-Functions.html" rel="next" title="Combined Initialization and Assignment Functions">
<link href="Initialization-Functions.html" rel="prev" title="Initialization Functions">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Assignment-Functions">
<div class="nav-panel">
<p>
Next: <a href="Combined-Initialization-and-Assignment-Functions.html" accesskey="n" rel="next">Combined Initialization and Assignment Functions</a>, Previous: <a href="Initialization-Functions.html" accesskey="p" rel="prev">Initialization Functions</a>, Up: <a href="MPFR-Interface.html" accesskey="u" rel="up">MPFR Interface</a>   [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a class="index-entry-id" id="index-Assignment-functions"></a>
<h3 class="section" id="Assignment-Functions-1">5.2 Assignment Functions</h3>

<p>These functions assign new values to already initialized floats
(see <a class="pxref" href="Initialization-Functions.html">Initialization Functions</a>).
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpfr_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fui"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_ui</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fui'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fsi"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_si</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long int <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fsi'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fuj"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_uj</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, uintmax_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fuj'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fsj"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_sj</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, intmax_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fsj'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fflt"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_flt</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, float <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fflt'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fd"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_d</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, double <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fd'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fld"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_ld</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long double <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fld'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005ffloat128"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_float128</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, _Float128 <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005ffloat128'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fdecimal64"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_decimal64</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, _Decimal64 <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fdecimal64'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fdecimal128"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_decimal128</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, _Decimal128 <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fdecimal128'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fz"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_z</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpz_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fz'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fq"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_q</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpq_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fq'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005ff"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_f</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpf_t <var class="var">op</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005ff'> ¶</a></span></dt>
<dd><p>Set the value of <var class="var">rop</var> from <var class="var">op</var>, rounded
toward the given direction <var class="var">rnd</var>.
Note that the input 0 is converted to +0 by <code class="code">mpfr_set_ui</code>,
<code class="code">mpfr_set_si</code>, <code class="code">mpfr_set_uj</code>, <code class="code">mpfr_set_sj</code>,
<code class="code">mpfr_set_z</code>, <code class="code">mpfr_set_q</code> and
<code class="code">mpfr_set_f</code>, regardless of the rounding mode.
The <code class="code">mpfr_set_float128</code> function is built only with the configure
option ‘<samp class="samp">--enable-float128</samp>’, which requires the compiler or
system provides the ‘<samp class="samp">_Float128</samp>’ data type
(GCC 4.3 or later supports this data type);
to use <code class="code">mpfr_set_float128</code>, one should define the macro
<code class="code">MPFR_WANT_FLOAT128</code> before including <samp class="file">mpfr.h</samp>.
If the system does not support the IEEE 754 standard,
<code class="code">mpfr_set_flt</code>, <code class="code">mpfr_set_d</code>, <code class="code">mpfr_set_ld</code>,
<code class="code">mpfr_set_decimal64</code> and <code class="code">mpfr_set_decimal128</code>
might not preserve the signed zeros
(and in any case they don’t preserve the sign bit of NaN).
The <code class="code">mpfr_set_decimal64</code> and <code class="code">mpfr_set_decimal128</code>
functions are built only with the configure
option ‘<samp class="samp">--enable-decimal-float</samp>’, and when the compiler or
system provides the ‘<samp class="samp">_Decimal64</samp>’ and ‘<samp class="samp">_Decimal128</samp>’ data type;
to use those functions, one should define the macro
<code class="code">MPFR_WANT_DECIMAL_FLOATS</code> before including <samp class="file">mpfr.h</samp>.
<code class="code">mpfr_set_q</code> might fail if the numerator (or the
denominator) cannot be represented as a <code class="code">mpfr_t</code>.
</p>
<p>For <code class="code">mpfr_set</code>, the sign of a NaN is propagated in order to mimic the
IEEE 754 <code class="code">copy</code> operation. But contrary to IEEE 754, the
NaN flag is set as usual.
</p>
<p>Note: If you want to store a floating-point constant to a <code class="code">mpfr_t</code>,
you should use <code class="code">mpfr_set_str</code> (or one of the MPFR constant functions,
such as <code class="code">mpfr_const_pi</code> for Pi) instead of
<code class="code">mpfr_set_flt</code>, <code class="code">mpfr_set_d</code>,
<code class="code">mpfr_set_ld</code>, <code class="code">mpfr_set_decimal64</code> or
<code class="code">mpfr_set_decimal128</code>.
Otherwise the floating-point constant will be first
converted into a reduced-precision (e.g., 53-bit) binary
(or decimal, for <code class="code">mpfr_set_decimal64</code> and <code class="code">mpfr_set_decimal128</code>)
number before MPFR can work with it.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005fui_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_ui_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, unsigned long int <var class="var">op</var>, mpfr_exp_t <var class="var">e</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fui_005f2exp'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fsi_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_si_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, long int <var class="var">op</var>, mpfr_exp_t <var class="var">e</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fsi_005f2exp'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fuj_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_uj_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, uintmax_t <var class="var">op</var>, intmax_t <var class="var">e</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fuj_005f2exp'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fsj_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_sj_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, intmax_t <var class="var">op</var>, intmax_t <var class="var">e</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fsj_005f2exp'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fz_005f2exp"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_z_2exp</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, mpz_t <var class="var">op</var>, mpfr_exp_t <var class="var">e</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fz_005f2exp'> ¶</a></span></dt>
<dd><p>Set the value of <var class="var">rop</var> from <var class="var">op</var> multiplied by
two to the power <var class="var">e</var>, rounded toward the given direction <var class="var">rnd</var>.
Note that the input 0 is converted to +0.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005fstr"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_set_str</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, const char *<var class="var">s</var>, int <var class="var">base</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fstr'> ¶</a></span></dt>
<dd><p>Set <var class="var">rop</var> to the value of the string <var class="var">s</var> in base <var class="var">base</var>,
rounded in the direction <var class="var">rnd</var>.
See the documentation of <code class="code">mpfr_strtofr</code> for a detailed description
of the valid string formats.
Contrary to <code class="code">mpfr_strtofr</code>, <code class="code">mpfr_set_str</code> requires the
<em class="emph">whole</em> string to represent a valid floating-point number.
</p>
<p>The meaning of the return value differs from other MPFR functions:
it is 0 if the entire string up to the final null character
is a valid number in base <var class="var">base</var>; otherwise it is −1, and
<var class="var">rop</var> may have changed (users interested in the <a class="ref" href="Rounding.html#ternary-value">ternary value</a>
should use <code class="code">mpfr_strtofr</code> instead).
</p>
<p>Note: it is preferable to use <code class="code">mpfr_strtofr</code> if one wants to distinguish
between an infinite <var class="var">rop</var> value coming from an infinite <var class="var">s</var> or from
an overflow.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fstrtofr"><span class="category-def">Function: </span><span><code class="def-type">int</code> <strong class="def-name">mpfr_strtofr</strong> <code class="def-code-arguments">(mpfr_t <var class="var">rop</var>, const char *<var class="var">nptr</var>, char **<var class="var">endptr</var>, int <var class="var">base</var>, mpfr_rnd_t <var class="var">rnd</var>)</code><a class="copiable-link" href='#index-mpfr_005fstrtofr'> ¶</a></span></dt>
<dd><p>Read a floating-point number from a string <var class="var">nptr</var> in base <var class="var">base</var>,
rounded in the direction <var class="var">rnd</var>; <var class="var">base</var> must be either 0 (to
detect the base, as described below) or a number from 2 to 62 (otherwise
the behavior is undefined). If <var class="var">nptr</var> starts with valid data, the
result is stored in <var class="var">rop</var> and <code class="code">*<var class="var">endptr</var></code> points to the
character just after the valid data (if <var class="var">endptr</var> is not a null pointer);
otherwise <var class="var">rop</var> is set to zero (for consistency with <code class="code">strtod</code>)
and the value of <var class="var">nptr</var> is stored
in the location referenced by <var class="var">endptr</var> (if <var class="var">endptr</var> is not a null
pointer). The usual ternary value is returned.
</p>
<p>Parsing follows the standard C <code class="code">strtod</code> function with some extensions.
After optional leading whitespace, one has a subject sequence consisting of an
optional sign (‘<samp class="samp">+</samp>’ or ‘<samp class="samp">-</samp>’), and either numeric data or special
data. The subject sequence is defined as the longest initial subsequence of
the input string, starting with the first non-whitespace character, that is of
the expected form.
</p>
<p>The form of numeric data is a non-empty sequence of significand digits with
an optional decimal-point character, and an optional exponent consisting of
an exponent prefix followed by an optional sign and a non-empty sequence of
decimal digits. A significand digit is either a decimal digit or a Latin
letter (62 possible characters), with ‘<samp class="samp">A</samp>’ = 10, ‘<samp class="samp">B</samp>’ = 11, …,
‘<samp class="samp">Z</samp>’ = 35; case is ignored in bases less than or equal to 36, in bases
larger than 36, ‘<samp class="samp">a</samp>’ = 36, ‘<samp class="samp">b</samp>’ = 37, …, ‘<samp class="samp">z</samp>’ = 61.
The value of a significand digit must be strictly less than the base. The
decimal-point character can be either the one defined by the current locale
or the period (the first one is accepted for consistency with the C standard
and the practice, the second one is accepted to allow the programmer to
provide MPFR numbers from strings in a way that does not depend on the
current locale).
The exponent prefix can be ‘<samp class="samp">e</samp>’ or ‘<samp class="samp">E</samp>’ for bases up to 10, or
‘<samp class="samp">@</samp>’ in any base; it indicates a multiplication by a power of the
base. In bases 2 and 16, the exponent prefix can also be ‘<samp class="samp">p</samp>’ or ‘<samp class="samp">P</samp>’,
in which case the exponent, called <em class="emph">binary exponent</em>, indicates a
multiplication by a power of 2 instead of the base (there is a difference
only for base 16); in base 16 for example ‘<samp class="samp">1p2</samp>’ represents 4 whereas
‘<samp class="samp">1@2</samp>’ represents 256. The value of an exponent is always written in
base 10.
</p>
<p>If the argument <var class="var">base</var> is 0, then the base is automatically detected
as follows. If the significand starts with ‘<samp class="samp">0b</samp>’ or ‘<samp class="samp">0B</samp>’, base 2
is assumed. If the significand starts with ‘<samp class="samp">0x</samp>’ or ‘<samp class="samp">0X</samp>’, base 16
is assumed. Otherwise base 10 is assumed.
</p>
<p>Note: The exponent (if present)
must contain at least a digit. Otherwise the possible
exponent prefix and sign are not part of the number (which ends with the
significand). Similarly, if ‘<samp class="samp">0b</samp>’, ‘<samp class="samp">0B</samp>’, ‘<samp class="samp">0x</samp>’ or ‘<samp class="samp">0X</samp>’
is not followed by a binary/hexadecimal digit, then the subject sequence
stops at the character ‘<samp class="samp">0</samp>’, thus 0 is read.
</p>
<p>Special data (for infinities and NaN) can be ‘<samp class="samp">@inf@</samp>’ or
‘<samp class="samp">@nan@(n-char-sequence-opt)</samp>’, and if <var class="var">base</var> &lt;= 16<!-- /@w -->,
it can also be ‘<samp class="samp">infinity</samp>’, ‘<samp class="samp">inf</samp>’, ‘<samp class="samp">nan</samp>’ or
‘<samp class="samp">nan(n-char-sequence-opt)</samp>’, all case insensitive with the rules of
the C locale.
An ‘<samp class="samp">n-char-sequence-opt</samp>’ is a possibly empty string containing only digits,
Latin letters and the underscore (0, 1, 2, …, 9, a, b, …, z,
A, B, …, Z, _). Note: one has an optional sign for all data, even
NaN.
For example, ‘<samp class="samp">-@nAn@(This_Is_Not_17)</samp>’ is a valid representation for NaN
in base 17.
</p>

</dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fset_005fnan"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_nan</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fnan'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005finf"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_inf</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, int <var class="var">sign</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005finf'> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-mpfr_005fset_005fzero"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_set_zero</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, int <var class="var">sign</var>)</code><a class="copiable-link" href='#index-mpfr_005fset_005fzero'> ¶</a></span></dt>
<dd><p>Set the variable <var class="var">x</var> to NaN (Not-a-Number), infinity or zero respectively.
In <code class="code">mpfr_set_inf</code> or <code class="code">mpfr_set_zero</code>, <var class="var">x</var> is set to positive
infinity (+Inf) or positive zero (+0) iff <var class="var">sign</var> is non-negative;
in <code class="code">mpfr_set_nan</code>, the sign bit of the result is unspecified.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-mpfr_005fswap"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">mpfr_swap</strong> <code class="def-code-arguments">(mpfr_t <var class="var">x</var>, mpfr_t <var class="var">y</var>)</code><a class="copiable-link" href='#index-mpfr_005fswap'> ¶</a></span></dt>
<dd><p>Swap the structures pointed to by <var class="var">x</var> and <var class="var">y</var>. In particular,
the values are exchanged without rounding (this may be different from
three <code class="code">mpfr_set</code> calls using a third auxiliary variable).
</p>
<p>Warning! Since the precisions are exchanged, this will affect future
assignments. Moreover, since the significand pointers are also exchanged,
you must not use this function if the allocation method used for <var class="var">x</var>
and/or <var class="var">y</var> does not permit it. This is the case when <var class="var">x</var> and/or
<var class="var">y</var> were declared and initialized with <code class="code">MPFR_DECL_INIT</code>, and
possibly with <code class="code">mpfr_custom_init_set</code> (see <a class="pxref" href="Custom-Interface.html">Custom Interface</a>).
</p></dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Combined-Initialization-and-Assignment-Functions.html">Combined Initialization and Assignment Functions</a>, Previous: <a href="Initialization-Functions.html">Initialization Functions</a>, Up: <a href="MPFR-Interface.html">MPFR Interface</a>   [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
