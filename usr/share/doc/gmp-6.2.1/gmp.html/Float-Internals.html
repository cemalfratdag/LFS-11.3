<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.0.2, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!-- This manual describes how to install and use the GNU multiple precision
arithmetic library, version 6.2.1.

Copyright 1991, 1993-2016, 2018-2020 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover Texts being "A GNU Manual", and with the Back-Cover
Texts being "You have freedom to copy and modify this GNU Manual, like GNU
software".  A copy of the license is included in
GNU Free Documentation License. -->
<title>Float Internals (GNU MP 6.2.1)</title>

<meta name="description" content="How to install and use the GNU multiple precision arithmetic library, version 6.2.1.">
<meta name="keywords" content="Float Internals (GNU MP 6.2.1)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Concept-Index.html" rel="index" title="Concept Index">
<link href="Internals.html" rel="up" title="Internals">
<link href="Raw-Output-Internals.html" rel="next" title="Raw Output Internals">
<link href="Rational-Internals.html" rel="prev" title="Rational Internals">
<style type="text/css">
<!--
div.example {margin-left: 3.2em}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="Float-Internals">
<div class="nav-panel">
<p>
Next: <a href="Raw-Output-Internals.html" accesskey="n" rel="next">Raw Output Internals</a>, Previous: <a href="Rational-Internals.html" accesskey="p" rel="prev">Rational Internals</a>, Up: <a href="Internals.html" accesskey="u" rel="up">Internals</a> &nbsp; [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Float-Internals-1">16.3 Float Internals</h3>
<a class="index-entry-id" id="index-Float-internals"></a>

<p>Efficient calculation is the primary aim of GMP floats and the use of whole
limbs and simple rounding facilitates this.
</p>
<p><code class="code">mpf_t</code> floats have a variable precision mantissa and a single machine
word signed exponent.  The mantissa is represented using sign and magnitude.
</p>
<div class="example">
<pre class="example-preformatted">   most                   least
significant            significant
   limb                   limb

                            _mp_d
 |---- _mp_exp ---&gt;           |
  _____ _____ _____ _____ _____
 |_____|_____|_____|_____|_____|
                   . &lt;------------ radix point

  &lt;-------- _mp_size ---------&gt;

</pre></div>

<p>The fields are as follows.
</p>
<dl class="table">
<dt><code class="code">_mp_size</code></dt>
<dd><p>The number of limbs currently in use, or the negative of that when
representing a negative value.  Zero is represented by <code class="code">_mp_size</code> and
<code class="code">_mp_exp</code> both set to zero, and in that case the <code class="code">_mp_d</code> data is
unused.  (In the future <code class="code">_mp_exp</code> might be undefined when representing
zero.)
</p>
</dd>
<dt><code class="code">_mp_prec</code></dt>
<dd><p>The precision of the mantissa, in limbs.  In any calculation the aim is to
produce <code class="code">_mp_prec</code> limbs of result (the most significant being non-zero).
</p>
</dd>
<dt><code class="code">_mp_d</code></dt>
<dd><p>A pointer to the array of limbs which is the absolute value of the mantissa.
These are stored &ldquo;little endian&rdquo; as per the <code class="code">mpn</code> functions, so
<code class="code">_mp_d[0]</code> is the least significant limb and
<code class="code">_mp_d[ABS(_mp_size)-1]</code> the most significant.
</p>
<p>The most significant limb is always non-zero, but there are no other
restrictions on its value, in particular the highest 1 bit can be anywhere
within the limb.
</p>
<p><code class="code">_mp_prec+1</code> limbs are allocated to <code class="code">_mp_d</code>, the extra limb being
for convenience (see below).  There are no reallocations during a calculation,
only in a change of precision with <code class="code">mpf_set_prec</code>.
</p>
</dd>
<dt><code class="code">_mp_exp</code></dt>
<dd><p>The exponent, in limbs, determining the location of the implied radix point.
Zero means the radix point is just above the most significant limb.  Positive
values mean a radix point offset towards the lower limbs and hence a value
<em class="math">&gt;= 1</em>, as for example in the diagram above.  Negative exponents mean
a radix point further above the highest limb.
</p>
<p>Naturally the exponent can be any value, it doesn&rsquo;t have to fall within the
limbs as the diagram shows, it can be a long way above or a long way below.
Limbs other than those included in the <code class="code">{_mp_d,_mp_size}</code> data
are treated as zero.
</p></dd>
</dl>

<p>The <code class="code">_mp_size</code> and <code class="code">_mp_prec</code> fields are <code class="code">int</code>, although the
<code class="code">mp_size_t</code> type is usually a <code class="code">long</code>.  The <code class="code">_mp_exp</code> field is
usually <code class="code">long</code>.  This is done to make some fields just 32 bits on some 64
bits systems, thereby saving a few bytes of data space but still providing
plenty of precision and a very large range.
</p>

<br>
<p>The following various points should be noted.
</p>
<dl class="table">
<dt>Low Zeros</dt>
<dd><p>The least significant limbs <code class="code">_mp_d[0]</code> etc can be zero, though such low
zeros can always be ignored.  Routines likely to produce low zeros check and
avoid them to save time in subsequent calculations, but for most routines
they&rsquo;re quite unlikely and aren&rsquo;t checked.
</p>
</dd>
<dt>Mantissa Size Range</dt>
<dd><p>The <code class="code">_mp_size</code> count of limbs in use can be less than <code class="code">_mp_prec</code> if
the value can be represented in less.  This means low precision values or
small integers stored in a high precision <code class="code">mpf_t</code> can still be operated
on efficiently.
</p>
<p><code class="code">_mp_size</code> can also be greater than <code class="code">_mp_prec</code>.  Firstly a value is
allowed to use all of the <code class="code">_mp_prec+1</code> limbs available at <code class="code">_mp_d</code>,
and secondly when <code class="code">mpf_set_prec_raw</code> lowers <code class="code">_mp_prec</code> it leaves
<code class="code">_mp_size</code> unchanged and so the size can be arbitrarily bigger than
<code class="code">_mp_prec</code>.
</p>
</dd>
<dt>Rounding</dt>
<dd><p>All rounding is done on limb boundaries.  Calculating <code class="code">_mp_prec</code> limbs
with the high non-zero will ensure the application requested minimum precision
is obtained.
</p>
<p>The use of simple &ldquo;trunc&rdquo; rounding towards zero is efficient, since there&rsquo;s
no need to examine extra limbs and increment or decrement.
</p>
</dd>
<dt>Bit Shifts</dt>
<dd><p>Since the exponent is in limbs, there are no bit shifts in basic operations
like <code class="code">mpf_add</code> and <code class="code">mpf_mul</code>.  When differing exponents are
encountered all that&rsquo;s needed is to adjust pointers to line up the relevant
limbs.
</p>
<p>Of course <code class="code">mpf_mul_2exp</code> and <code class="code">mpf_div_2exp</code> will require bit shifts,
but the choice is between an exponent in limbs which requires shifts there, or
one in bits which requires them almost everywhere else.
</p>
</dd>
<dt>Use of <code class="code">_mp_prec+1</code> Limbs</dt>
<dd><p>The extra limb on <code class="code">_mp_d</code> (<code class="code">_mp_prec+1</code> rather than just
<code class="code">_mp_prec</code>) helps when an <code class="code">mpf</code> routine might get a carry from its
operation.  <code class="code">mpf_add</code> for instance will do an <code class="code">mpn_add</code> of
<code class="code">_mp_prec</code> limbs.  If there&rsquo;s no carry then that&rsquo;s the result, but if
there is a carry then it&rsquo;s stored in the extra limb of space and
<code class="code">_mp_size</code> becomes <code class="code">_mp_prec+1</code>.
</p>
<p>Whenever <code class="code">_mp_prec+1</code> limbs are held in a variable, the low limb is not
needed for the intended precision, only the <code class="code">_mp_prec</code> high limbs.  But
zeroing it out or moving the rest down is unnecessary.  Subsequent routines
reading the value will simply take the high limbs they need, and this will be
<code class="code">_mp_prec</code> if their target has that same precision.  This is no more than
a pointer adjustment, and must be checked anyway since the destination
precision can be different from the sources.
</p>
<p>Copy functions like <code class="code">mpf_set</code> will retain a full <code class="code">_mp_prec+1</code> limbs
if available.  This ensures that a variable which has <code class="code">_mp_size</code> equal to
<code class="code">_mp_prec+1</code> will get its full exact value copied.  Strictly speaking
this is unnecessary since only <code class="code">_mp_prec</code> limbs are needed for the
application&rsquo;s requested precision, but it&rsquo;s considered that an <code class="code">mpf_set</code>
from one variable into another of the same precision ought to produce an exact
copy.
</p>
</dd>
<dt>Application Precisions</dt>
<dd><p><code class="code">__GMPF_BITS_TO_PREC</code> converts an application requested precision to an
<code class="code">_mp_prec</code>.  The value in bits is rounded up to a whole limb then an
extra limb is added since the most significant limb of <code class="code">_mp_d</code> is only
non-zero and therefore might contain only one bit.
</p>
<p><code class="code">__GMPF_PREC_TO_BITS</code> does the reverse conversion, and removes the extra
limb from <code class="code">_mp_prec</code> before converting to bits.  The net effect of
reading back with <code class="code">mpf_get_prec</code> is simply the precision rounded up to a
multiple of <code class="code">mp_bits_per_limb</code>.
</p>
<p>Note that the extra limb added here for the high only being non-zero is in
addition to the extra limb allocated to <code class="code">_mp_d</code>.  For example with a
32-bit limb, an application request for 250 bits will be rounded up to 8
limbs, then an extra added for the high being only non-zero, giving an
<code class="code">_mp_prec</code> of 9.  <code class="code">_mp_d</code> then gets 10 limbs allocated.  Reading
back with <code class="code">mpf_get_prec</code> will take <code class="code">_mp_prec</code> subtract 1 limb and
multiply by 32, giving 256 bits.
</p>
<p>Strictly speaking, the fact the high limb has at least one bit means that a
float with, say, 3 limbs of 32-bits each will be holding at least 65 bits, but
for the purposes of <code class="code">mpf_t</code> it&rsquo;s considered simply to be 64 bits, a nice
multiple of the limb size.
</p></dd>
</dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="Raw-Output-Internals.html">Raw Output Internals</a>, Previous: <a href="Rational-Internals.html">Rational Internals</a>, Up: <a href="Internals.html">Internals</a> &nbsp; [<a href="Concept-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
